// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockwritelock

import (
	"context"
	"sync"
	"time"

	"github.com/dcbickfo/redcache/internal/writelock"
)

// Ensure that MockWriteLockManager does implement writelock.WriteLockManager.
// If this is not the case, regenerate this file with mockery.
var _ writelock.WriteLockManager = &MockWriteLockManager{}

// MockWriteLockManager is a mock implementation of writelock.WriteLockManager.
//
//	func TestSomethingThatUsesWriteLockManager(t *testing.T) {
//
//		// make and configure a mocked writelock.WriteLockManager
//		mockedWriteLockManager := &MockWriteLockManager{
//			AcquireMultiWriteLocksFunc: func(ctx context.Context, keys []string) (map[string]string, map[string]string, []string, error) {
//				panic("mock out the AcquireMultiWriteLocks method")
//			},
//			AcquireMultiWriteLocksSequentialFunc: func(ctx context.Context, keys []string) (map[string]string, map[string]string, error) {
//				panic("mock out the AcquireMultiWriteLocksSequential method")
//			},
//			AcquireWriteLockFunc: func(ctx context.Context, key string) (string, error) {
//				panic("mock out the AcquireWriteLock method")
//			},
//			CommitWriteLocksFunc: func(ctx context.Context, ttl time.Duration, lockValues map[string]string, actualValues map[string]string) (map[string]string, map[string]error) {
//				panic("mock out the CommitWriteLocks method")
//			},
//			ReleaseWriteLockFunc: func(ctx context.Context, key string, lockValue string) error {
//				panic("mock out the ReleaseWriteLock method")
//			},
//			ReleaseWriteLocksFunc: func(ctx context.Context, lockValues map[string]string)  {
//				panic("mock out the ReleaseWriteLocks method")
//			},
//			RestoreValuesFunc: func(ctx context.Context, savedValues map[string]string, lockValues map[string]string)  {
//				panic("mock out the RestoreValues method")
//			},
//			TouchLocksFunc: func(ctx context.Context, lockValues map[string]string)  {
//				panic("mock out the TouchLocks method")
//			},
//		}
//
//		// use mockedWriteLockManager in code that requires writelock.WriteLockManager
//		// and then make assertions.
//
//	}
type MockWriteLockManager struct {
	// AcquireMultiWriteLocksFunc mocks the AcquireMultiWriteLocks method.
	AcquireMultiWriteLocksFunc func(ctx context.Context, keys []string) (map[string]string, map[string]string, []string, error)

	// AcquireMultiWriteLocksSequentialFunc mocks the AcquireMultiWriteLocksSequential method.
	AcquireMultiWriteLocksSequentialFunc func(ctx context.Context, keys []string) (map[string]string, map[string]string, error)

	// AcquireWriteLockFunc mocks the AcquireWriteLock method.
	AcquireWriteLockFunc func(ctx context.Context, key string) (string, error)

	// CommitWriteLocksFunc mocks the CommitWriteLocks method.
	CommitWriteLocksFunc func(ctx context.Context, ttl time.Duration, lockValues map[string]string, actualValues map[string]string) (map[string]string, map[string]error)

	// ReleaseWriteLockFunc mocks the ReleaseWriteLock method.
	ReleaseWriteLockFunc func(ctx context.Context, key string, lockValue string) error

	// ReleaseWriteLocksFunc mocks the ReleaseWriteLocks method.
	ReleaseWriteLocksFunc func(ctx context.Context, lockValues map[string]string)

	// RestoreValuesFunc mocks the RestoreValues method.
	RestoreValuesFunc func(ctx context.Context, savedValues map[string]string, lockValues map[string]string)

	// TouchLocksFunc mocks the TouchLocks method.
	TouchLocksFunc func(ctx context.Context, lockValues map[string]string)

	// calls tracks calls to the methods.
	calls struct {
		// AcquireMultiWriteLocks holds details about calls to the AcquireMultiWriteLocks method.
		AcquireMultiWriteLocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// AcquireMultiWriteLocksSequential holds details about calls to the AcquireMultiWriteLocksSequential method.
		AcquireMultiWriteLocksSequential []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// AcquireWriteLock holds details about calls to the AcquireWriteLock method.
		AcquireWriteLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// CommitWriteLocks holds details about calls to the CommitWriteLocks method.
		CommitWriteLocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TTL is the ttl argument value.
			TTL time.Duration
			// LockValues is the lockValues argument value.
			LockValues map[string]string
			// ActualValues is the actualValues argument value.
			ActualValues map[string]string
		}
		// ReleaseWriteLock holds details about calls to the ReleaseWriteLock method.
		ReleaseWriteLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// LockValue is the lockValue argument value.
			LockValue string
		}
		// ReleaseWriteLocks holds details about calls to the ReleaseWriteLocks method.
		ReleaseWriteLocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LockValues is the lockValues argument value.
			LockValues map[string]string
		}
		// RestoreValues holds details about calls to the RestoreValues method.
		RestoreValues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SavedValues is the savedValues argument value.
			SavedValues map[string]string
			// LockValues is the lockValues argument value.
			LockValues map[string]string
		}
		// TouchLocks holds details about calls to the TouchLocks method.
		TouchLocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LockValues is the lockValues argument value.
			LockValues map[string]string
		}
	}
	lockAcquireMultiWriteLocks           sync.RWMutex
	lockAcquireMultiWriteLocksSequential sync.RWMutex
	lockAcquireWriteLock                 sync.RWMutex
	lockCommitWriteLocks                 sync.RWMutex
	lockReleaseWriteLock                 sync.RWMutex
	lockReleaseWriteLocks                sync.RWMutex
	lockRestoreValues                    sync.RWMutex
	lockTouchLocks                       sync.RWMutex
}

// AcquireMultiWriteLocks calls AcquireMultiWriteLocksFunc.
func (mock *MockWriteLockManager) AcquireMultiWriteLocks(ctx context.Context, keys []string) (map[string]string, map[string]string, []string, error) {
	if mock.AcquireMultiWriteLocksFunc == nil {
		panic("MockWriteLockManager.AcquireMultiWriteLocksFunc: method is nil but WriteLockManager.AcquireMultiWriteLocks was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockAcquireMultiWriteLocks.Lock()
	mock.calls.AcquireMultiWriteLocks = append(mock.calls.AcquireMultiWriteLocks, callInfo)
	mock.lockAcquireMultiWriteLocks.Unlock()
	return mock.AcquireMultiWriteLocksFunc(ctx, keys)
}

// AcquireMultiWriteLocksCalls gets all the calls that were made to AcquireMultiWriteLocks.
// Check the length with:
//
//	len(mockedWriteLockManager.AcquireMultiWriteLocksCalls())
func (mock *MockWriteLockManager) AcquireMultiWriteLocksCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockAcquireMultiWriteLocks.RLock()
	calls = mock.calls.AcquireMultiWriteLocks
	mock.lockAcquireMultiWriteLocks.RUnlock()
	return calls
}

// AcquireMultiWriteLocksSequential calls AcquireMultiWriteLocksSequentialFunc.
func (mock *MockWriteLockManager) AcquireMultiWriteLocksSequential(ctx context.Context, keys []string) (map[string]string, map[string]string, error) {
	if mock.AcquireMultiWriteLocksSequentialFunc == nil {
		panic("MockWriteLockManager.AcquireMultiWriteLocksSequentialFunc: method is nil but WriteLockManager.AcquireMultiWriteLocksSequential was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockAcquireMultiWriteLocksSequential.Lock()
	mock.calls.AcquireMultiWriteLocksSequential = append(mock.calls.AcquireMultiWriteLocksSequential, callInfo)
	mock.lockAcquireMultiWriteLocksSequential.Unlock()
	return mock.AcquireMultiWriteLocksSequentialFunc(ctx, keys)
}

// AcquireMultiWriteLocksSequentialCalls gets all the calls that were made to AcquireMultiWriteLocksSequential.
// Check the length with:
//
//	len(mockedWriteLockManager.AcquireMultiWriteLocksSequentialCalls())
func (mock *MockWriteLockManager) AcquireMultiWriteLocksSequentialCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockAcquireMultiWriteLocksSequential.RLock()
	calls = mock.calls.AcquireMultiWriteLocksSequential
	mock.lockAcquireMultiWriteLocksSequential.RUnlock()
	return calls
}

// AcquireWriteLock calls AcquireWriteLockFunc.
func (mock *MockWriteLockManager) AcquireWriteLock(ctx context.Context, key string) (string, error) {
	if mock.AcquireWriteLockFunc == nil {
		panic("MockWriteLockManager.AcquireWriteLockFunc: method is nil but WriteLockManager.AcquireWriteLock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockAcquireWriteLock.Lock()
	mock.calls.AcquireWriteLock = append(mock.calls.AcquireWriteLock, callInfo)
	mock.lockAcquireWriteLock.Unlock()
	return mock.AcquireWriteLockFunc(ctx, key)
}

// AcquireWriteLockCalls gets all the calls that were made to AcquireWriteLock.
// Check the length with:
//
//	len(mockedWriteLockManager.AcquireWriteLockCalls())
func (mock *MockWriteLockManager) AcquireWriteLockCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockAcquireWriteLock.RLock()
	calls = mock.calls.AcquireWriteLock
	mock.lockAcquireWriteLock.RUnlock()
	return calls
}

// CommitWriteLocks calls CommitWriteLocksFunc.
func (mock *MockWriteLockManager) CommitWriteLocks(ctx context.Context, ttl time.Duration, lockValues map[string]string, actualValues map[string]string) (map[string]string, map[string]error) {
	if mock.CommitWriteLocksFunc == nil {
		panic("MockWriteLockManager.CommitWriteLocksFunc: method is nil but WriteLockManager.CommitWriteLocks was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		TTL          time.Duration
		LockValues   map[string]string
		ActualValues map[string]string
	}{
		Ctx:          ctx,
		TTL:          ttl,
		LockValues:   lockValues,
		ActualValues: actualValues,
	}
	mock.lockCommitWriteLocks.Lock()
	mock.calls.CommitWriteLocks = append(mock.calls.CommitWriteLocks, callInfo)
	mock.lockCommitWriteLocks.Unlock()
	return mock.CommitWriteLocksFunc(ctx, ttl, lockValues, actualValues)
}

// CommitWriteLocksCalls gets all the calls that were made to CommitWriteLocks.
// Check the length with:
//
//	len(mockedWriteLockManager.CommitWriteLocksCalls())
func (mock *MockWriteLockManager) CommitWriteLocksCalls() []struct {
	Ctx          context.Context
	TTL          time.Duration
	LockValues   map[string]string
	ActualValues map[string]string
} {
	var calls []struct {
		Ctx          context.Context
		TTL          time.Duration
		LockValues   map[string]string
		ActualValues map[string]string
	}
	mock.lockCommitWriteLocks.RLock()
	calls = mock.calls.CommitWriteLocks
	mock.lockCommitWriteLocks.RUnlock()
	return calls
}

// ReleaseWriteLock calls ReleaseWriteLockFunc.
func (mock *MockWriteLockManager) ReleaseWriteLock(ctx context.Context, key string, lockValue string) error {
	if mock.ReleaseWriteLockFunc == nil {
		panic("MockWriteLockManager.ReleaseWriteLockFunc: method is nil but WriteLockManager.ReleaseWriteLock was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		LockValue string
	}{
		Ctx:       ctx,
		Key:       key,
		LockValue: lockValue,
	}
	mock.lockReleaseWriteLock.Lock()
	mock.calls.ReleaseWriteLock = append(mock.calls.ReleaseWriteLock, callInfo)
	mock.lockReleaseWriteLock.Unlock()
	return mock.ReleaseWriteLockFunc(ctx, key, lockValue)
}

// ReleaseWriteLockCalls gets all the calls that were made to ReleaseWriteLock.
// Check the length with:
//
//	len(mockedWriteLockManager.ReleaseWriteLockCalls())
func (mock *MockWriteLockManager) ReleaseWriteLockCalls() []struct {
	Ctx       context.Context
	Key       string
	LockValue string
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		LockValue string
	}
	mock.lockReleaseWriteLock.RLock()
	calls = mock.calls.ReleaseWriteLock
	mock.lockReleaseWriteLock.RUnlock()
	return calls
}

// ReleaseWriteLocks calls ReleaseWriteLocksFunc.
func (mock *MockWriteLockManager) ReleaseWriteLocks(ctx context.Context, lockValues map[string]string) {
	if mock.ReleaseWriteLocksFunc == nil {
		panic("MockWriteLockManager.ReleaseWriteLocksFunc: method is nil but WriteLockManager.ReleaseWriteLocks was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		LockValues map[string]string
	}{
		Ctx:        ctx,
		LockValues: lockValues,
	}
	mock.lockReleaseWriteLocks.Lock()
	mock.calls.ReleaseWriteLocks = append(mock.calls.ReleaseWriteLocks, callInfo)
	mock.lockReleaseWriteLocks.Unlock()
	mock.ReleaseWriteLocksFunc(ctx, lockValues)
}

// ReleaseWriteLocksCalls gets all the calls that were made to ReleaseWriteLocks.
// Check the length with:
//
//	len(mockedWriteLockManager.ReleaseWriteLocksCalls())
func (mock *MockWriteLockManager) ReleaseWriteLocksCalls() []struct {
	Ctx        context.Context
	LockValues map[string]string
} {
	var calls []struct {
		Ctx        context.Context
		LockValues map[string]string
	}
	mock.lockReleaseWriteLocks.RLock()
	calls = mock.calls.ReleaseWriteLocks
	mock.lockReleaseWriteLocks.RUnlock()
	return calls
}

// RestoreValues calls RestoreValuesFunc.
func (mock *MockWriteLockManager) RestoreValues(ctx context.Context, savedValues map[string]string, lockValues map[string]string) {
	if mock.RestoreValuesFunc == nil {
		panic("MockWriteLockManager.RestoreValuesFunc: method is nil but WriteLockManager.RestoreValues was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		SavedValues map[string]string
		LockValues  map[string]string
	}{
		Ctx:         ctx,
		SavedValues: savedValues,
		LockValues:  lockValues,
	}
	mock.lockRestoreValues.Lock()
	mock.calls.RestoreValues = append(mock.calls.RestoreValues, callInfo)
	mock.lockRestoreValues.Unlock()
	mock.RestoreValuesFunc(ctx, savedValues, lockValues)
}

// RestoreValuesCalls gets all the calls that were made to RestoreValues.
// Check the length with:
//
//	len(mockedWriteLockManager.RestoreValuesCalls())
func (mock *MockWriteLockManager) RestoreValuesCalls() []struct {
	Ctx         context.Context
	SavedValues map[string]string
	LockValues  map[string]string
} {
	var calls []struct {
		Ctx         context.Context
		SavedValues map[string]string
		LockValues  map[string]string
	}
	mock.lockRestoreValues.RLock()
	calls = mock.calls.RestoreValues
	mock.lockRestoreValues.RUnlock()
	return calls
}

// TouchLocks calls TouchLocksFunc.
func (mock *MockWriteLockManager) TouchLocks(ctx context.Context, lockValues map[string]string) {
	if mock.TouchLocksFunc == nil {
		panic("MockWriteLockManager.TouchLocksFunc: method is nil but WriteLockManager.TouchLocks was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		LockValues map[string]string
	}{
		Ctx:        ctx,
		LockValues: lockValues,
	}
	mock.lockTouchLocks.Lock()
	mock.calls.TouchLocks = append(mock.calls.TouchLocks, callInfo)
	mock.lockTouchLocks.Unlock()
	mock.TouchLocksFunc(ctx, lockValues)
}

// TouchLocksCalls gets all the calls that were made to TouchLocks.
// Check the length with:
//
//	len(mockedWriteLockManager.TouchLocksCalls())
func (mock *MockWriteLockManager) TouchLocksCalls() []struct {
	Ctx        context.Context
	LockValues map[string]string
} {
	var calls []struct {
		Ctx        context.Context
		LockValues map[string]string
	}
	mock.lockTouchLocks.RLock()
	calls = mock.calls.TouchLocks
	mock.lockTouchLocks.RUnlock()
	return calls
}
