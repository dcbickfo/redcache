// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockinvalidation

import (
	"iter"
	"sync"

	"github.com/dcbickfo/redcache/internal/invalidation"
	"github.com/redis/rueidis"
)

// Ensure that MockHandler does implement invalidation.Handler.
// If this is not the case, regenerate this file with mockery.
var _ invalidation.Handler = &MockHandler{}

// MockHandler is a mock implementation of invalidation.Handler.
//
//	func TestSomethingThatUsesHandler(t *testing.T) {
//
//		// make and configure a mocked invalidation.Handler
//		mockedHandler := &MockHandler{
//			OnInvalidateFunc: func(messages []rueidis.RedisMessage)  {
//				panic("mock out the OnInvalidate method")
//			},
//			RegisterFunc: func(key string) <-chan struct{} {
//				panic("mock out the Register method")
//			},
//			RegisterAllFunc: func(keys iter.Seq[string], length int) map[string]<-chan struct{} {
//				panic("mock out the RegisterAll method")
//			},
//		}
//
//		// use mockedHandler in code that requires invalidation.Handler
//		// and then make assertions.
//
//	}
type MockHandler struct {
	// OnInvalidateFunc mocks the OnInvalidate method.
	OnInvalidateFunc func(messages []rueidis.RedisMessage)

	// RegisterFunc mocks the Register method.
	RegisterFunc func(key string) <-chan struct{}

	// RegisterAllFunc mocks the RegisterAll method.
	RegisterAllFunc func(keys iter.Seq[string], length int) map[string]<-chan struct{}

	// calls tracks calls to the methods.
	calls struct {
		// OnInvalidate holds details about calls to the OnInvalidate method.
		OnInvalidate []struct {
			// Messages is the messages argument value.
			Messages []rueidis.RedisMessage
		}
		// Register holds details about calls to the Register method.
		Register []struct {
			// Key is the key argument value.
			Key string
		}
		// RegisterAll holds details about calls to the RegisterAll method.
		RegisterAll []struct {
			// Keys is the keys argument value.
			Keys iter.Seq[string]
			// Length is the length argument value.
			Length int
		}
	}
	lockOnInvalidate sync.RWMutex
	lockRegister     sync.RWMutex
	lockRegisterAll  sync.RWMutex
}

// OnInvalidate calls OnInvalidateFunc.
func (mock *MockHandler) OnInvalidate(messages []rueidis.RedisMessage) {
	if mock.OnInvalidateFunc == nil {
		panic("MockHandler.OnInvalidateFunc: method is nil but Handler.OnInvalidate was just called")
	}
	callInfo := struct {
		Messages []rueidis.RedisMessage
	}{
		Messages: messages,
	}
	mock.lockOnInvalidate.Lock()
	mock.calls.OnInvalidate = append(mock.calls.OnInvalidate, callInfo)
	mock.lockOnInvalidate.Unlock()
	mock.OnInvalidateFunc(messages)
}

// OnInvalidateCalls gets all the calls that were made to OnInvalidate.
// Check the length with:
//
//	len(mockedHandler.OnInvalidateCalls())
func (mock *MockHandler) OnInvalidateCalls() []struct {
	Messages []rueidis.RedisMessage
} {
	var calls []struct {
		Messages []rueidis.RedisMessage
	}
	mock.lockOnInvalidate.RLock()
	calls = mock.calls.OnInvalidate
	mock.lockOnInvalidate.RUnlock()
	return calls
}

// Register calls RegisterFunc.
func (mock *MockHandler) Register(key string) <-chan struct{} {
	if mock.RegisterFunc == nil {
		panic("MockHandler.RegisterFunc: method is nil but Handler.Register was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockRegister.Lock()
	mock.calls.Register = append(mock.calls.Register, callInfo)
	mock.lockRegister.Unlock()
	return mock.RegisterFunc(key)
}

// RegisterCalls gets all the calls that were made to Register.
// Check the length with:
//
//	len(mockedHandler.RegisterCalls())
func (mock *MockHandler) RegisterCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockRegister.RLock()
	calls = mock.calls.Register
	mock.lockRegister.RUnlock()
	return calls
}

// RegisterAll calls RegisterAllFunc.
func (mock *MockHandler) RegisterAll(keys iter.Seq[string], length int) map[string]<-chan struct{} {
	if mock.RegisterAllFunc == nil {
		panic("MockHandler.RegisterAllFunc: method is nil but Handler.RegisterAll was just called")
	}
	callInfo := struct {
		Keys   iter.Seq[string]
		Length int
	}{
		Keys:   keys,
		Length: length,
	}
	mock.lockRegisterAll.Lock()
	mock.calls.RegisterAll = append(mock.calls.RegisterAll, callInfo)
	mock.lockRegisterAll.Unlock()
	return mock.RegisterAllFunc(keys, length)
}

// RegisterAllCalls gets all the calls that were made to RegisterAll.
// Check the length with:
//
//	len(mockedHandler.RegisterAllCalls())
func (mock *MockHandler) RegisterAllCalls() []struct {
	Keys   iter.Seq[string]
	Length int
} {
	var calls []struct {
		Keys   iter.Seq[string]
		Length int
	}
	mock.lockRegisterAll.RLock()
	calls = mock.calls.RegisterAll
	mock.lockRegisterAll.RUnlock()
	return calls
}
