// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mocklockmanager

import (
	"context"
	"sync"
	"time"

	"github.com/dcbickfo/redcache/internal/lockmanager"
	"github.com/redis/rueidis"
)

// Ensure that MockLockManager does implement lockmanager.LockManager.
// If this is not the case, regenerate this file with mockery.
var _ lockmanager.LockManager = &MockLockManager{}

// MockLockManager is a mock implementation of lockmanager.LockManager.
//
//	func TestSomethingThatUsesLockManager(t *testing.T) {
//
//		// make and configure a mocked lockmanager.LockManager
//		mockedLockManager := &MockLockManager{
//			AcquireLockBlockingFunc: func(ctx context.Context, key string) (string, error) {
//				panic("mock out the AcquireLockBlocking method")
//			},
//			AcquireMultiLocksBlockingFunc: func(ctx context.Context, keys []string) (map[string]string, error) {
//				panic("mock out the AcquireMultiLocksBlocking method")
//			},
//			CheckKeyLockedFunc: func(ctx context.Context, key string) bool {
//				panic("mock out the CheckKeyLocked method")
//			},
//			CheckMultiKeysLockedFunc: func(ctx context.Context, keys []string) []string {
//				panic("mock out the CheckMultiKeysLocked method")
//			},
//			CleanupUnusedLocksFunc: func(ctx context.Context, acquiredLocks map[string]string, usedKeys map[string]string)  {
//				panic("mock out the CleanupUnusedLocks method")
//			},
//			CommitReadLocksFunc: func(ctx context.Context, ttl time.Duration, lockValues map[string]string, actualValues map[string]string) ([]string, []string, error) {
//				panic("mock out the CommitReadLocks method")
//			},
//			CreateImmediateWaitHandleFunc: func() lockmanager.WaitHandle {
//				panic("mock out the CreateImmediateWaitHandle method")
//			},
//			GenerateLockValueFunc: func() string {
//				panic("mock out the GenerateLockValue method")
//			},
//			IsLockValueFunc: func(val string) bool {
//				panic("mock out the IsLockValue method")
//			},
//			LockPrefixFunc: func() string {
//				panic("mock out the LockPrefix method")
//			},
//			OnInvalidateFunc: func(messages []rueidis.RedisMessage)  {
//				panic("mock out the OnInvalidate method")
//			},
//			ReleaseLockFunc: func(ctx context.Context, key string, lockValue string) error {
//				panic("mock out the ReleaseLock method")
//			},
//			ReleaseMultiLocksFunc: func(ctx context.Context, lockValues map[string]string)  {
//				panic("mock out the ReleaseMultiLocks method")
//			},
//			TryAcquireFunc: func(ctx context.Context, key string) (string, lockmanager.WaitHandle, error) {
//				panic("mock out the TryAcquire method")
//			},
//			TryAcquireMultiFunc: func(ctx context.Context, keys []string) (map[string]string, map[string]lockmanager.WaitHandle, error) {
//				panic("mock out the TryAcquireMulti method")
//			},
//			WaitForKeyFunc: func(key string) lockmanager.WaitHandle {
//				panic("mock out the WaitForKey method")
//			},
//			WaitForKeyWithRetryFunc: func(ctx context.Context, key string, ticker *time.Ticker) error {
//				panic("mock out the WaitForKeyWithRetry method")
//			},
//			WaitForKeyWithSubscriptionFunc: func(ctx context.Context, key string, cacheTTL time.Duration) (lockmanager.WaitHandle, string, error) {
//				panic("mock out the WaitForKeyWithSubscription method")
//			},
//		}
//
//		// use mockedLockManager in code that requires lockmanager.LockManager
//		// and then make assertions.
//
//	}
type MockLockManager struct {
	// AcquireLockBlockingFunc mocks the AcquireLockBlocking method.
	AcquireLockBlockingFunc func(ctx context.Context, key string) (string, error)

	// AcquireMultiLocksBlockingFunc mocks the AcquireMultiLocksBlocking method.
	AcquireMultiLocksBlockingFunc func(ctx context.Context, keys []string) (map[string]string, error)

	// CheckKeyLockedFunc mocks the CheckKeyLocked method.
	CheckKeyLockedFunc func(ctx context.Context, key string) bool

	// CheckMultiKeysLockedFunc mocks the CheckMultiKeysLocked method.
	CheckMultiKeysLockedFunc func(ctx context.Context, keys []string) []string

	// CleanupUnusedLocksFunc mocks the CleanupUnusedLocks method.
	CleanupUnusedLocksFunc func(ctx context.Context, acquiredLocks map[string]string, usedKeys map[string]string)

	// CommitReadLocksFunc mocks the CommitReadLocks method.
	CommitReadLocksFunc func(ctx context.Context, ttl time.Duration, lockValues map[string]string, actualValues map[string]string) ([]string, []string, error)

	// CreateImmediateWaitHandleFunc mocks the CreateImmediateWaitHandle method.
	CreateImmediateWaitHandleFunc func() lockmanager.WaitHandle

	// GenerateLockValueFunc mocks the GenerateLockValue method.
	GenerateLockValueFunc func() string

	// IsLockValueFunc mocks the IsLockValue method.
	IsLockValueFunc func(val string) bool

	// LockPrefixFunc mocks the LockPrefix method.
	LockPrefixFunc func() string

	// OnInvalidateFunc mocks the OnInvalidate method.
	OnInvalidateFunc func(messages []rueidis.RedisMessage)

	// ReleaseLockFunc mocks the ReleaseLock method.
	ReleaseLockFunc func(ctx context.Context, key string, lockValue string) error

	// ReleaseMultiLocksFunc mocks the ReleaseMultiLocks method.
	ReleaseMultiLocksFunc func(ctx context.Context, lockValues map[string]string)

	// TryAcquireFunc mocks the TryAcquire method.
	TryAcquireFunc func(ctx context.Context, key string) (string, lockmanager.WaitHandle, error)

	// TryAcquireMultiFunc mocks the TryAcquireMulti method.
	TryAcquireMultiFunc func(ctx context.Context, keys []string) (map[string]string, map[string]lockmanager.WaitHandle, error)

	// WaitForKeyFunc mocks the WaitForKey method.
	WaitForKeyFunc func(key string) lockmanager.WaitHandle

	// WaitForKeyWithRetryFunc mocks the WaitForKeyWithRetry method.
	WaitForKeyWithRetryFunc func(ctx context.Context, key string, ticker *time.Ticker) error

	// WaitForKeyWithSubscriptionFunc mocks the WaitForKeyWithSubscription method.
	WaitForKeyWithSubscriptionFunc func(ctx context.Context, key string, cacheTTL time.Duration) (lockmanager.WaitHandle, string, error)

	// calls tracks calls to the methods.
	calls struct {
		// AcquireLockBlocking holds details about calls to the AcquireLockBlocking method.
		AcquireLockBlocking []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// AcquireMultiLocksBlocking holds details about calls to the AcquireMultiLocksBlocking method.
		AcquireMultiLocksBlocking []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// CheckKeyLocked holds details about calls to the CheckKeyLocked method.
		CheckKeyLocked []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// CheckMultiKeysLocked holds details about calls to the CheckMultiKeysLocked method.
		CheckMultiKeysLocked []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// CleanupUnusedLocks holds details about calls to the CleanupUnusedLocks method.
		CleanupUnusedLocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AcquiredLocks is the acquiredLocks argument value.
			AcquiredLocks map[string]string
			// UsedKeys is the usedKeys argument value.
			UsedKeys map[string]string
		}
		// CommitReadLocks holds details about calls to the CommitReadLocks method.
		CommitReadLocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TTL is the ttl argument value.
			TTL time.Duration
			// LockValues is the lockValues argument value.
			LockValues map[string]string
			// ActualValues is the actualValues argument value.
			ActualValues map[string]string
		}
		// CreateImmediateWaitHandle holds details about calls to the CreateImmediateWaitHandle method.
		CreateImmediateWaitHandle []struct {
		}
		// GenerateLockValue holds details about calls to the GenerateLockValue method.
		GenerateLockValue []struct {
		}
		// IsLockValue holds details about calls to the IsLockValue method.
		IsLockValue []struct {
			// Val is the val argument value.
			Val string
		}
		// LockPrefix holds details about calls to the LockPrefix method.
		LockPrefix []struct {
		}
		// OnInvalidate holds details about calls to the OnInvalidate method.
		OnInvalidate []struct {
			// Messages is the messages argument value.
			Messages []rueidis.RedisMessage
		}
		// ReleaseLock holds details about calls to the ReleaseLock method.
		ReleaseLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// LockValue is the lockValue argument value.
			LockValue string
		}
		// ReleaseMultiLocks holds details about calls to the ReleaseMultiLocks method.
		ReleaseMultiLocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LockValues is the lockValues argument value.
			LockValues map[string]string
		}
		// TryAcquire holds details about calls to the TryAcquire method.
		TryAcquire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TryAcquireMulti holds details about calls to the TryAcquireMulti method.
		TryAcquireMulti []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// WaitForKey holds details about calls to the WaitForKey method.
		WaitForKey []struct {
			// Key is the key argument value.
			Key string
		}
		// WaitForKeyWithRetry holds details about calls to the WaitForKeyWithRetry method.
		WaitForKeyWithRetry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Ticker is the ticker argument value.
			Ticker *time.Ticker
		}
		// WaitForKeyWithSubscription holds details about calls to the WaitForKeyWithSubscription method.
		WaitForKeyWithSubscription []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// CacheTTL is the cacheTTL argument value.
			CacheTTL time.Duration
		}
	}
	lockAcquireLockBlocking        sync.RWMutex
	lockAcquireMultiLocksBlocking  sync.RWMutex
	lockCheckKeyLocked             sync.RWMutex
	lockCheckMultiKeysLocked       sync.RWMutex
	lockCleanupUnusedLocks         sync.RWMutex
	lockCommitReadLocks            sync.RWMutex
	lockCreateImmediateWaitHandle  sync.RWMutex
	lockGenerateLockValue          sync.RWMutex
	lockIsLockValue                sync.RWMutex
	lockLockPrefix                 sync.RWMutex
	lockOnInvalidate               sync.RWMutex
	lockReleaseLock                sync.RWMutex
	lockReleaseMultiLocks          sync.RWMutex
	lockTryAcquire                 sync.RWMutex
	lockTryAcquireMulti            sync.RWMutex
	lockWaitForKey                 sync.RWMutex
	lockWaitForKeyWithRetry        sync.RWMutex
	lockWaitForKeyWithSubscription sync.RWMutex
}

// AcquireLockBlocking calls AcquireLockBlockingFunc.
func (mock *MockLockManager) AcquireLockBlocking(ctx context.Context, key string) (string, error) {
	if mock.AcquireLockBlockingFunc == nil {
		panic("MockLockManager.AcquireLockBlockingFunc: method is nil but LockManager.AcquireLockBlocking was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockAcquireLockBlocking.Lock()
	mock.calls.AcquireLockBlocking = append(mock.calls.AcquireLockBlocking, callInfo)
	mock.lockAcquireLockBlocking.Unlock()
	return mock.AcquireLockBlockingFunc(ctx, key)
}

// AcquireLockBlockingCalls gets all the calls that were made to AcquireLockBlocking.
// Check the length with:
//
//	len(mockedLockManager.AcquireLockBlockingCalls())
func (mock *MockLockManager) AcquireLockBlockingCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockAcquireLockBlocking.RLock()
	calls = mock.calls.AcquireLockBlocking
	mock.lockAcquireLockBlocking.RUnlock()
	return calls
}

// AcquireMultiLocksBlocking calls AcquireMultiLocksBlockingFunc.
func (mock *MockLockManager) AcquireMultiLocksBlocking(ctx context.Context, keys []string) (map[string]string, error) {
	if mock.AcquireMultiLocksBlockingFunc == nil {
		panic("MockLockManager.AcquireMultiLocksBlockingFunc: method is nil but LockManager.AcquireMultiLocksBlocking was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockAcquireMultiLocksBlocking.Lock()
	mock.calls.AcquireMultiLocksBlocking = append(mock.calls.AcquireMultiLocksBlocking, callInfo)
	mock.lockAcquireMultiLocksBlocking.Unlock()
	return mock.AcquireMultiLocksBlockingFunc(ctx, keys)
}

// AcquireMultiLocksBlockingCalls gets all the calls that were made to AcquireMultiLocksBlocking.
// Check the length with:
//
//	len(mockedLockManager.AcquireMultiLocksBlockingCalls())
func (mock *MockLockManager) AcquireMultiLocksBlockingCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockAcquireMultiLocksBlocking.RLock()
	calls = mock.calls.AcquireMultiLocksBlocking
	mock.lockAcquireMultiLocksBlocking.RUnlock()
	return calls
}

// CheckKeyLocked calls CheckKeyLockedFunc.
func (mock *MockLockManager) CheckKeyLocked(ctx context.Context, key string) bool {
	if mock.CheckKeyLockedFunc == nil {
		panic("MockLockManager.CheckKeyLockedFunc: method is nil but LockManager.CheckKeyLocked was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockCheckKeyLocked.Lock()
	mock.calls.CheckKeyLocked = append(mock.calls.CheckKeyLocked, callInfo)
	mock.lockCheckKeyLocked.Unlock()
	return mock.CheckKeyLockedFunc(ctx, key)
}

// CheckKeyLockedCalls gets all the calls that were made to CheckKeyLocked.
// Check the length with:
//
//	len(mockedLockManager.CheckKeyLockedCalls())
func (mock *MockLockManager) CheckKeyLockedCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockCheckKeyLocked.RLock()
	calls = mock.calls.CheckKeyLocked
	mock.lockCheckKeyLocked.RUnlock()
	return calls
}

// CheckMultiKeysLocked calls CheckMultiKeysLockedFunc.
func (mock *MockLockManager) CheckMultiKeysLocked(ctx context.Context, keys []string) []string {
	if mock.CheckMultiKeysLockedFunc == nil {
		panic("MockLockManager.CheckMultiKeysLockedFunc: method is nil but LockManager.CheckMultiKeysLocked was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockCheckMultiKeysLocked.Lock()
	mock.calls.CheckMultiKeysLocked = append(mock.calls.CheckMultiKeysLocked, callInfo)
	mock.lockCheckMultiKeysLocked.Unlock()
	return mock.CheckMultiKeysLockedFunc(ctx, keys)
}

// CheckMultiKeysLockedCalls gets all the calls that were made to CheckMultiKeysLocked.
// Check the length with:
//
//	len(mockedLockManager.CheckMultiKeysLockedCalls())
func (mock *MockLockManager) CheckMultiKeysLockedCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockCheckMultiKeysLocked.RLock()
	calls = mock.calls.CheckMultiKeysLocked
	mock.lockCheckMultiKeysLocked.RUnlock()
	return calls
}

// CleanupUnusedLocks calls CleanupUnusedLocksFunc.
func (mock *MockLockManager) CleanupUnusedLocks(ctx context.Context, acquiredLocks map[string]string, usedKeys map[string]string) {
	if mock.CleanupUnusedLocksFunc == nil {
		panic("MockLockManager.CleanupUnusedLocksFunc: method is nil but LockManager.CleanupUnusedLocks was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		AcquiredLocks map[string]string
		UsedKeys      map[string]string
	}{
		Ctx:           ctx,
		AcquiredLocks: acquiredLocks,
		UsedKeys:      usedKeys,
	}
	mock.lockCleanupUnusedLocks.Lock()
	mock.calls.CleanupUnusedLocks = append(mock.calls.CleanupUnusedLocks, callInfo)
	mock.lockCleanupUnusedLocks.Unlock()
	mock.CleanupUnusedLocksFunc(ctx, acquiredLocks, usedKeys)
}

// CleanupUnusedLocksCalls gets all the calls that were made to CleanupUnusedLocks.
// Check the length with:
//
//	len(mockedLockManager.CleanupUnusedLocksCalls())
func (mock *MockLockManager) CleanupUnusedLocksCalls() []struct {
	Ctx           context.Context
	AcquiredLocks map[string]string
	UsedKeys      map[string]string
} {
	var calls []struct {
		Ctx           context.Context
		AcquiredLocks map[string]string
		UsedKeys      map[string]string
	}
	mock.lockCleanupUnusedLocks.RLock()
	calls = mock.calls.CleanupUnusedLocks
	mock.lockCleanupUnusedLocks.RUnlock()
	return calls
}

// CommitReadLocks calls CommitReadLocksFunc.
func (mock *MockLockManager) CommitReadLocks(ctx context.Context, ttl time.Duration, lockValues map[string]string, actualValues map[string]string) ([]string, []string, error) {
	if mock.CommitReadLocksFunc == nil {
		panic("MockLockManager.CommitReadLocksFunc: method is nil but LockManager.CommitReadLocks was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		TTL          time.Duration
		LockValues   map[string]string
		ActualValues map[string]string
	}{
		Ctx:          ctx,
		TTL:          ttl,
		LockValues:   lockValues,
		ActualValues: actualValues,
	}
	mock.lockCommitReadLocks.Lock()
	mock.calls.CommitReadLocks = append(mock.calls.CommitReadLocks, callInfo)
	mock.lockCommitReadLocks.Unlock()
	return mock.CommitReadLocksFunc(ctx, ttl, lockValues, actualValues)
}

// CommitReadLocksCalls gets all the calls that were made to CommitReadLocks.
// Check the length with:
//
//	len(mockedLockManager.CommitReadLocksCalls())
func (mock *MockLockManager) CommitReadLocksCalls() []struct {
	Ctx          context.Context
	TTL          time.Duration
	LockValues   map[string]string
	ActualValues map[string]string
} {
	var calls []struct {
		Ctx          context.Context
		TTL          time.Duration
		LockValues   map[string]string
		ActualValues map[string]string
	}
	mock.lockCommitReadLocks.RLock()
	calls = mock.calls.CommitReadLocks
	mock.lockCommitReadLocks.RUnlock()
	return calls
}

// CreateImmediateWaitHandle calls CreateImmediateWaitHandleFunc.
func (mock *MockLockManager) CreateImmediateWaitHandle() lockmanager.WaitHandle {
	if mock.CreateImmediateWaitHandleFunc == nil {
		panic("MockLockManager.CreateImmediateWaitHandleFunc: method is nil but LockManager.CreateImmediateWaitHandle was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCreateImmediateWaitHandle.Lock()
	mock.calls.CreateImmediateWaitHandle = append(mock.calls.CreateImmediateWaitHandle, callInfo)
	mock.lockCreateImmediateWaitHandle.Unlock()
	return mock.CreateImmediateWaitHandleFunc()
}

// CreateImmediateWaitHandleCalls gets all the calls that were made to CreateImmediateWaitHandle.
// Check the length with:
//
//	len(mockedLockManager.CreateImmediateWaitHandleCalls())
func (mock *MockLockManager) CreateImmediateWaitHandleCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCreateImmediateWaitHandle.RLock()
	calls = mock.calls.CreateImmediateWaitHandle
	mock.lockCreateImmediateWaitHandle.RUnlock()
	return calls
}

// GenerateLockValue calls GenerateLockValueFunc.
func (mock *MockLockManager) GenerateLockValue() string {
	if mock.GenerateLockValueFunc == nil {
		panic("MockLockManager.GenerateLockValueFunc: method is nil but LockManager.GenerateLockValue was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGenerateLockValue.Lock()
	mock.calls.GenerateLockValue = append(mock.calls.GenerateLockValue, callInfo)
	mock.lockGenerateLockValue.Unlock()
	return mock.GenerateLockValueFunc()
}

// GenerateLockValueCalls gets all the calls that were made to GenerateLockValue.
// Check the length with:
//
//	len(mockedLockManager.GenerateLockValueCalls())
func (mock *MockLockManager) GenerateLockValueCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGenerateLockValue.RLock()
	calls = mock.calls.GenerateLockValue
	mock.lockGenerateLockValue.RUnlock()
	return calls
}

// IsLockValue calls IsLockValueFunc.
func (mock *MockLockManager) IsLockValue(val string) bool {
	if mock.IsLockValueFunc == nil {
		panic("MockLockManager.IsLockValueFunc: method is nil but LockManager.IsLockValue was just called")
	}
	callInfo := struct {
		Val string
	}{
		Val: val,
	}
	mock.lockIsLockValue.Lock()
	mock.calls.IsLockValue = append(mock.calls.IsLockValue, callInfo)
	mock.lockIsLockValue.Unlock()
	return mock.IsLockValueFunc(val)
}

// IsLockValueCalls gets all the calls that were made to IsLockValue.
// Check the length with:
//
//	len(mockedLockManager.IsLockValueCalls())
func (mock *MockLockManager) IsLockValueCalls() []struct {
	Val string
} {
	var calls []struct {
		Val string
	}
	mock.lockIsLockValue.RLock()
	calls = mock.calls.IsLockValue
	mock.lockIsLockValue.RUnlock()
	return calls
}

// LockPrefix calls LockPrefixFunc.
func (mock *MockLockManager) LockPrefix() string {
	if mock.LockPrefixFunc == nil {
		panic("MockLockManager.LockPrefixFunc: method is nil but LockManager.LockPrefix was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLockPrefix.Lock()
	mock.calls.LockPrefix = append(mock.calls.LockPrefix, callInfo)
	mock.lockLockPrefix.Unlock()
	return mock.LockPrefixFunc()
}

// LockPrefixCalls gets all the calls that were made to LockPrefix.
// Check the length with:
//
//	len(mockedLockManager.LockPrefixCalls())
func (mock *MockLockManager) LockPrefixCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLockPrefix.RLock()
	calls = mock.calls.LockPrefix
	mock.lockLockPrefix.RUnlock()
	return calls
}

// OnInvalidate calls OnInvalidateFunc.
func (mock *MockLockManager) OnInvalidate(messages []rueidis.RedisMessage) {
	if mock.OnInvalidateFunc == nil {
		panic("MockLockManager.OnInvalidateFunc: method is nil but LockManager.OnInvalidate was just called")
	}
	callInfo := struct {
		Messages []rueidis.RedisMessage
	}{
		Messages: messages,
	}
	mock.lockOnInvalidate.Lock()
	mock.calls.OnInvalidate = append(mock.calls.OnInvalidate, callInfo)
	mock.lockOnInvalidate.Unlock()
	mock.OnInvalidateFunc(messages)
}

// OnInvalidateCalls gets all the calls that were made to OnInvalidate.
// Check the length with:
//
//	len(mockedLockManager.OnInvalidateCalls())
func (mock *MockLockManager) OnInvalidateCalls() []struct {
	Messages []rueidis.RedisMessage
} {
	var calls []struct {
		Messages []rueidis.RedisMessage
	}
	mock.lockOnInvalidate.RLock()
	calls = mock.calls.OnInvalidate
	mock.lockOnInvalidate.RUnlock()
	return calls
}

// ReleaseLock calls ReleaseLockFunc.
func (mock *MockLockManager) ReleaseLock(ctx context.Context, key string, lockValue string) error {
	if mock.ReleaseLockFunc == nil {
		panic("MockLockManager.ReleaseLockFunc: method is nil but LockManager.ReleaseLock was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		LockValue string
	}{
		Ctx:       ctx,
		Key:       key,
		LockValue: lockValue,
	}
	mock.lockReleaseLock.Lock()
	mock.calls.ReleaseLock = append(mock.calls.ReleaseLock, callInfo)
	mock.lockReleaseLock.Unlock()
	return mock.ReleaseLockFunc(ctx, key, lockValue)
}

// ReleaseLockCalls gets all the calls that were made to ReleaseLock.
// Check the length with:
//
//	len(mockedLockManager.ReleaseLockCalls())
func (mock *MockLockManager) ReleaseLockCalls() []struct {
	Ctx       context.Context
	Key       string
	LockValue string
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		LockValue string
	}
	mock.lockReleaseLock.RLock()
	calls = mock.calls.ReleaseLock
	mock.lockReleaseLock.RUnlock()
	return calls
}

// ReleaseMultiLocks calls ReleaseMultiLocksFunc.
func (mock *MockLockManager) ReleaseMultiLocks(ctx context.Context, lockValues map[string]string) {
	if mock.ReleaseMultiLocksFunc == nil {
		panic("MockLockManager.ReleaseMultiLocksFunc: method is nil but LockManager.ReleaseMultiLocks was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		LockValues map[string]string
	}{
		Ctx:        ctx,
		LockValues: lockValues,
	}
	mock.lockReleaseMultiLocks.Lock()
	mock.calls.ReleaseMultiLocks = append(mock.calls.ReleaseMultiLocks, callInfo)
	mock.lockReleaseMultiLocks.Unlock()
	mock.ReleaseMultiLocksFunc(ctx, lockValues)
}

// ReleaseMultiLocksCalls gets all the calls that were made to ReleaseMultiLocks.
// Check the length with:
//
//	len(mockedLockManager.ReleaseMultiLocksCalls())
func (mock *MockLockManager) ReleaseMultiLocksCalls() []struct {
	Ctx        context.Context
	LockValues map[string]string
} {
	var calls []struct {
		Ctx        context.Context
		LockValues map[string]string
	}
	mock.lockReleaseMultiLocks.RLock()
	calls = mock.calls.ReleaseMultiLocks
	mock.lockReleaseMultiLocks.RUnlock()
	return calls
}

// TryAcquire calls TryAcquireFunc.
func (mock *MockLockManager) TryAcquire(ctx context.Context, key string) (string, lockmanager.WaitHandle, error) {
	if mock.TryAcquireFunc == nil {
		panic("MockLockManager.TryAcquireFunc: method is nil but LockManager.TryAcquire was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTryAcquire.Lock()
	mock.calls.TryAcquire = append(mock.calls.TryAcquire, callInfo)
	mock.lockTryAcquire.Unlock()
	return mock.TryAcquireFunc(ctx, key)
}

// TryAcquireCalls gets all the calls that were made to TryAcquire.
// Check the length with:
//
//	len(mockedLockManager.TryAcquireCalls())
func (mock *MockLockManager) TryAcquireCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTryAcquire.RLock()
	calls = mock.calls.TryAcquire
	mock.lockTryAcquire.RUnlock()
	return calls
}

// TryAcquireMulti calls TryAcquireMultiFunc.
func (mock *MockLockManager) TryAcquireMulti(ctx context.Context, keys []string) (map[string]string, map[string]lockmanager.WaitHandle, error) {
	if mock.TryAcquireMultiFunc == nil {
		panic("MockLockManager.TryAcquireMultiFunc: method is nil but LockManager.TryAcquireMulti was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockTryAcquireMulti.Lock()
	mock.calls.TryAcquireMulti = append(mock.calls.TryAcquireMulti, callInfo)
	mock.lockTryAcquireMulti.Unlock()
	return mock.TryAcquireMultiFunc(ctx, keys)
}

// TryAcquireMultiCalls gets all the calls that were made to TryAcquireMulti.
// Check the length with:
//
//	len(mockedLockManager.TryAcquireMultiCalls())
func (mock *MockLockManager) TryAcquireMultiCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockTryAcquireMulti.RLock()
	calls = mock.calls.TryAcquireMulti
	mock.lockTryAcquireMulti.RUnlock()
	return calls
}

// WaitForKey calls WaitForKeyFunc.
func (mock *MockLockManager) WaitForKey(key string) lockmanager.WaitHandle {
	if mock.WaitForKeyFunc == nil {
		panic("MockLockManager.WaitForKeyFunc: method is nil but LockManager.WaitForKey was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockWaitForKey.Lock()
	mock.calls.WaitForKey = append(mock.calls.WaitForKey, callInfo)
	mock.lockWaitForKey.Unlock()
	return mock.WaitForKeyFunc(key)
}

// WaitForKeyCalls gets all the calls that were made to WaitForKey.
// Check the length with:
//
//	len(mockedLockManager.WaitForKeyCalls())
func (mock *MockLockManager) WaitForKeyCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockWaitForKey.RLock()
	calls = mock.calls.WaitForKey
	mock.lockWaitForKey.RUnlock()
	return calls
}

// WaitForKeyWithRetry calls WaitForKeyWithRetryFunc.
func (mock *MockLockManager) WaitForKeyWithRetry(ctx context.Context, key string, ticker *time.Ticker) error {
	if mock.WaitForKeyWithRetryFunc == nil {
		panic("MockLockManager.WaitForKeyWithRetryFunc: method is nil but LockManager.WaitForKeyWithRetry was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Ticker *time.Ticker
	}{
		Ctx:    ctx,
		Key:    key,
		Ticker: ticker,
	}
	mock.lockWaitForKeyWithRetry.Lock()
	mock.calls.WaitForKeyWithRetry = append(mock.calls.WaitForKeyWithRetry, callInfo)
	mock.lockWaitForKeyWithRetry.Unlock()
	return mock.WaitForKeyWithRetryFunc(ctx, key, ticker)
}

// WaitForKeyWithRetryCalls gets all the calls that were made to WaitForKeyWithRetry.
// Check the length with:
//
//	len(mockedLockManager.WaitForKeyWithRetryCalls())
func (mock *MockLockManager) WaitForKeyWithRetryCalls() []struct {
	Ctx    context.Context
	Key    string
	Ticker *time.Ticker
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Ticker *time.Ticker
	}
	mock.lockWaitForKeyWithRetry.RLock()
	calls = mock.calls.WaitForKeyWithRetry
	mock.lockWaitForKeyWithRetry.RUnlock()
	return calls
}

// WaitForKeyWithSubscription calls WaitForKeyWithSubscriptionFunc.
func (mock *MockLockManager) WaitForKeyWithSubscription(ctx context.Context, key string, cacheTTL time.Duration) (lockmanager.WaitHandle, string, error) {
	if mock.WaitForKeyWithSubscriptionFunc == nil {
		panic("MockLockManager.WaitForKeyWithSubscriptionFunc: method is nil but LockManager.WaitForKeyWithSubscription was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		CacheTTL time.Duration
	}{
		Ctx:      ctx,
		Key:      key,
		CacheTTL: cacheTTL,
	}
	mock.lockWaitForKeyWithSubscription.Lock()
	mock.calls.WaitForKeyWithSubscription = append(mock.calls.WaitForKeyWithSubscription, callInfo)
	mock.lockWaitForKeyWithSubscription.Unlock()
	return mock.WaitForKeyWithSubscriptionFunc(ctx, key, cacheTTL)
}

// WaitForKeyWithSubscriptionCalls gets all the calls that were made to WaitForKeyWithSubscription.
// Check the length with:
//
//	len(mockedLockManager.WaitForKeyWithSubscriptionCalls())
func (mock *MockLockManager) WaitForKeyWithSubscriptionCalls() []struct {
	Ctx      context.Context
	Key      string
	CacheTTL time.Duration
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		CacheTTL time.Duration
	}
	mock.lockWaitForKeyWithSubscription.RLock()
	calls = mock.calls.WaitForKeyWithSubscription
	mock.lockWaitForKeyWithSubscription.RUnlock()
	return calls
}
