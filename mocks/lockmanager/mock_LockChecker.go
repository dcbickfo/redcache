// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mocklockmanager

import (
	"context"
	"sync"

	"github.com/dcbickfo/redcache/internal/lockmanager"
	"github.com/redis/rueidis"
)

// Ensure that MockLockChecker does implement lockmanager.LockChecker.
// If this is not the case, regenerate this file with mockery.
var _ lockmanager.LockChecker = &MockLockChecker{}

// MockLockChecker is a mock implementation of lockmanager.LockChecker.
//
//	func TestSomethingThatUsesLockChecker(t *testing.T) {
//
//		// make and configure a mocked lockmanager.LockChecker
//		mockedLockChecker := &MockLockChecker{
//			CheckKeyLockedFunc: func(ctx context.Context, client rueidis.Client, key string) bool {
//				panic("mock out the CheckKeyLocked method")
//			},
//			HasLockFunc: func(val string) bool {
//				panic("mock out the HasLock method")
//			},
//		}
//
//		// use mockedLockChecker in code that requires lockmanager.LockChecker
//		// and then make assertions.
//
//	}
type MockLockChecker struct {
	// CheckKeyLockedFunc mocks the CheckKeyLocked method.
	CheckKeyLockedFunc func(ctx context.Context, client rueidis.Client, key string) bool

	// HasLockFunc mocks the HasLock method.
	HasLockFunc func(val string) bool

	// calls tracks calls to the methods.
	calls struct {
		// CheckKeyLocked holds details about calls to the CheckKeyLocked method.
		CheckKeyLocked []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Client is the client argument value.
			Client rueidis.Client
			// Key is the key argument value.
			Key string
		}
		// HasLock holds details about calls to the HasLock method.
		HasLock []struct {
			// Val is the val argument value.
			Val string
		}
	}
	lockCheckKeyLocked sync.RWMutex
	lockHasLock        sync.RWMutex
}

// CheckKeyLocked calls CheckKeyLockedFunc.
func (mock *MockLockChecker) CheckKeyLocked(ctx context.Context, client rueidis.Client, key string) bool {
	if mock.CheckKeyLockedFunc == nil {
		panic("MockLockChecker.CheckKeyLockedFunc: method is nil but LockChecker.CheckKeyLocked was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Client rueidis.Client
		Key    string
	}{
		Ctx:    ctx,
		Client: client,
		Key:    key,
	}
	mock.lockCheckKeyLocked.Lock()
	mock.calls.CheckKeyLocked = append(mock.calls.CheckKeyLocked, callInfo)
	mock.lockCheckKeyLocked.Unlock()
	return mock.CheckKeyLockedFunc(ctx, client, key)
}

// CheckKeyLockedCalls gets all the calls that were made to CheckKeyLocked.
// Check the length with:
//
//	len(mockedLockChecker.CheckKeyLockedCalls())
func (mock *MockLockChecker) CheckKeyLockedCalls() []struct {
	Ctx    context.Context
	Client rueidis.Client
	Key    string
} {
	var calls []struct {
		Ctx    context.Context
		Client rueidis.Client
		Key    string
	}
	mock.lockCheckKeyLocked.RLock()
	calls = mock.calls.CheckKeyLocked
	mock.lockCheckKeyLocked.RUnlock()
	return calls
}

// HasLock calls HasLockFunc.
func (mock *MockLockChecker) HasLock(val string) bool {
	if mock.HasLockFunc == nil {
		panic("MockLockChecker.HasLockFunc: method is nil but LockChecker.HasLock was just called")
	}
	callInfo := struct {
		Val string
	}{
		Val: val,
	}
	mock.lockHasLock.Lock()
	mock.calls.HasLock = append(mock.calls.HasLock, callInfo)
	mock.lockHasLock.Unlock()
	return mock.HasLockFunc(val)
}

// HasLockCalls gets all the calls that were made to HasLock.
// Check the length with:
//
//	len(mockedLockChecker.HasLockCalls())
func (mock *MockLockChecker) HasLockCalls() []struct {
	Val string
} {
	var calls []struct {
		Val string
	}
	mock.lockHasLock.RLock()
	calls = mock.calls.HasLock
	mock.lockHasLock.RUnlock()
	return calls
}
